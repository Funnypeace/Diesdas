<!DOCTYPE html>
<html lang="en">
<head>
    <title>Interactive 3D Earth Demo (Stable Version)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info-popup {
            position: absolute;
            left: 50%;
            top: 10%;
            transform: translate(-50%, 0);
            background: rgba(20,28,42,0.92);
            color: #fff;
            padding: 16px 32px;
            border-radius: 12px;
            font-family: sans-serif;
            font-size: 1.2em;
            pointer-events: none;
            z-index: 9;
            display: none;
            min-width: 200px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.25);
        }
        #audio-btn {
            position: absolute;
            bottom: 24px; left: 24px;
            background: rgba(32,32,64,0.8);
            color: #fff;
            font-size: 1.1em;
            border: none;
            border-radius: 12px;
            padding: 12px 20px;
            z-index: 9;
            cursor: pointer;
            display: none;
        }
    </style>
</head>
<body>
<div id="info-popup"></div>
<button id="audio-btn">ðŸ”Š Musik starten</button>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
<script>
// ----------- Texture Loading -----------
const manager = new THREE.LoadingManager(() => {
    // After ALL textures loaded, start scene
    start();
});
const loader = new THREE.TextureLoader(manager);

const textures = {};
textures.day = loader.load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/earthmap1k.jpg');
textures.night = loader.load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/earthlights1k.jpg');
textures.specular = loader.load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/earthspec1k.jpg');
textures.normal = loader.load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/earthbump1k.jpg');
textures.cloud = loader.load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/earthcloudmap.jpg');
textures.cloudAlpha = loader.load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/earthcloudmaptrans.jpg');
textures.stars = loader.load('https://www.solarsystemscope.com/textures/download/2k_stars.jpg');
textures.moon = loader.load('https://www.solarsystemscope.com/textures/download/2k_moon.jpg');

// ----------- Start -----------
function start() {
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.22;
controls.minDistance = 1.5;
controls.maxDistance = 5;
controls.maxPolarAngle = Math.PI * 0.97;

// Stats
const stats = new Stats();
document.body.appendChild(stats.dom);

// Starfield
const starGeometry = new THREE.SphereGeometry(100, 64, 64);
const starMaterial = new THREE.MeshBasicMaterial({ map: textures.stars, side: THREE.BackSide });
const stars = new THREE.Mesh(starGeometry, starMaterial);
scene.add(stars);

// Lights
const sunLight = new THREE.DirectionalLight(0xffffff, 1.22);
sunLight.castShadow = true;
scene.add(sunLight);

const ambientLight = new THREE.AmbientLight(0x222244, 0.8);
scene.add(ambientLight);

// ---- Earth
const earthRadius = 1;
const earthGeometry = new THREE.SphereGeometry(earthRadius, 64, 64);
const earthMaterial = new THREE.MeshPhongMaterial({
    map: textures.day,
    normalMap: textures.normal,
    normalScale: new THREE.Vector2(0.5, 0.5),
    specularMap: textures.specular,
    specular: new THREE.Color(0x222222),
    shininess: 7,
    emissiveMap: textures.night,
    emissive: new THREE.Color(0x333333),
    emissiveIntensity: 1.2,
});
const earth = new THREE.Mesh(earthGeometry, earthMaterial);
earth.castShadow = true;
earth.receiveShadow = true;
scene.add(earth);

// ---- Clouds
const cloudGeometry = new THREE.SphereGeometry(earthRadius + 0.013, 64, 64);
const cloudMaterial = new THREE.MeshPhongMaterial({
    map: textures.cloud,
    alphaMap: textures.cloudAlpha,
    transparent: true,
    opacity: 1.0,
    depthWrite: false
});
const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
clouds.castShadow = false;
clouds.receiveShadow = false;
scene.add(clouds);

// ---- Atmosphere Glow (simple)
const atmosphereGeometry = new THREE.SphereGeometry(earthRadius * 1.07, 64, 64);
const atmosphereMaterial = new THREE.MeshPhongMaterial({
    color: 0x66bbff,
    transparent: true,
    opacity: 0.18,
    side: THREE.BackSide
});
const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
scene.add(atmosphere);

// ---- Moon
const moonRadius = 0.27;
const moonGeometry = new THREE.SphereGeometry(moonRadius, 48, 48);
const moonMaterial = new THREE.MeshPhongMaterial({
    map: textures.moon,
    shininess: 2
});
const moon = new THREE.Mesh(moonGeometry, moonMaterial);
scene.add(moon);

const moonLight = new THREE.PointLight(0xaaaacc, 0.15, 12);
scene.add(moonLight);

// --- City Lights (PointLights)
const majorCities = [
    [52.52, 13.40, "Berlin"],
    [35.68, 139.76, "Tokyo"],
    [40.71, -74.01, "New York"],
    [48.85, 2.35, "Paris"],
    [34.05, -118.25, "Los Angeles"],
    [31.23, 121.47, "Shanghai"],
    [-23.55, -46.63, "SÃ£o Paulo"],
    [55.75, 37.61, "Moscow"]
];
let cityLights = [];
majorCities.forEach(([lat, lon], idx) => {
    const phi = (90 - lat) * Math.PI / 180;
    const theta = (lon + 180) * Math.PI / 180;
    const r = earthRadius + 0.04;
    const x = r * Math.sin(phi) * Math.cos(theta);
    const y = r * Math.cos(phi);
    const z = r * Math.sin(phi) * Math.sin(theta);
    const cityLight = new THREE.PointLight(0xffe570, 0.0, 0.5);
    cityLight.position.set(x, y, z);
    scene.add(cityLight);
    cityLights.push(cityLight);
});

// Rain Particles over Europe
const rainDrops = [];
const rainGroup = new THREE.Group();
for (let i = 0; i < 80; i++) {
    const geometry = new THREE.SphereGeometry(0.005, 6, 6);
    const material = new THREE.MeshBasicMaterial({ color: 0x66bbff });
    const phi = (90 - (45 + Math.random() * 12)) * Math.PI / 180;
    const theta = (10 + Math.random() * 16) * Math.PI / 180;
    const r = earthRadius + 0.055;
    const drop = new THREE.Mesh(geometry, material);
    drop.position.set(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.cos(phi),
        r * Math.sin(phi) * Math.sin(theta)
    );
    rainGroup.add(drop);
    rainDrops.push(drop);
}
scene.add(rainGroup);

// --- Audio mit Howler.js ---
let ambientMusic;
let musicStarted = false;
function initMusic() {
    if (musicStarted) return;
    musicStarted = true;
    document.getElementById('audio-btn').style.display = 'none';
    ambientMusic = new Howl({
        src: ['https://cdn.pixabay.com/audio/2022/02/23/audio_117b9b5f4a.mp3'],
        autoplay: true,
        loop: true,
        volume: 0.22
    });
    ambientMusic.play();
}
document.getElementById('audio-btn').style.display = 'block';
document.getElementById('audio-btn').onclick = initMusic;
document.body.addEventListener('pointerdown', initMusic, { once: true });

// --- Info-Popup fÃ¼r Klicks ---
const infoPopup = document.getElementById('info-popup');
function showInfo(txt) {
    infoPopup.innerHTML = txt;
    infoPopup.style.display = 'block';
    setTimeout(() => infoPopup.style.display = 'none', 2800);
}

// --- Raycaster fÃ¼r interaktive Regionen (vereinfacht) ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
function onClick(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(earth);
    if (intersects.length > 0) {
        const p = intersects[0].point.clone().normalize();
        const lat = 90 - Math.acos(p.y) * 180 / Math.PI;
        const lon = ((Math.atan2(p.z, p.x)) * 180 / Math.PI + 360) % 360 - 180;
        let msg = "";
        if (lat > 55) msg = "Das ist die Arktis.";
        else if (lat < -60) msg = "Das ist die Antarktis.";
        else if (lat > 35 && lon > -10 && lon < 40) msg = "Europa";
        else if (lat > 5 && lat < 60 && lon > -170 && lon < -30) msg = "Nordamerika";
        else if (lat < -10 && lon > -85 && lon < -30) msg = "SÃ¼damerika";
        else if (lat < 35 && lon > 100 && lon < 180) msg = "Australien/Ozeanien";
        else if (lat > 10 && lat < 55 && lon > 60 && lon < 150) msg = "Asien";
        else if (lat > -35 && lat < 35 && lon > -20 && lon < 50) msg = "Afrika";
        else msg = "Ozean/Meer";
        showInfo(`<b>Klick-Koordinaten:</b><br>Lat: ${lat.toFixed(2)}, Lon: ${lon.toFixed(2)}<br>${msg}`);
    }
}
window.addEventListener('click', onClick);

// --- Kamera ---
camera.position.set(0, 0, 2.4);

// --- Animation ---
let start = Date.now();
function animate() {
    requestAnimationFrame(animate);

    const elapsed = (Date.now() - start) / 1000;

    earth.rotation.y += 0.0010;
    clouds.rotation.y += 0.0013 + Math.sin(elapsed * 0.4) * 0.0002;
    atmosphere.rotation.copy(earth.rotation);

    // Sonne umkreist die Erde auf Y-Ebene
    const sunOrbitRad = 4.5;
    const sunAngle = elapsed * 0.16;
    sunLight.position.set(
        Math.cos(sunAngle) * sunOrbitRad,
        Math.sin(sunAngle) * sunOrbitRad * 0.55,
        Math.sin(sunAngle) * sunOrbitRad
    );

    // AmbientLight Tag/Nacht-Dimmung
    const cameraDir = new THREE.Vector3(0, 0, 1).applyQuaternion(camera.quaternion);
    const sunToCamera = sunLight.position.clone().normalize().dot(cameraDir);
    ambientLight.intensity = 0.35 + 0.5 * Math.max(0, sunToCamera);

    // Mond
    const moonOrbitRad = 2.1;
    const moonAngle = elapsed * 0.055 + 0.9;
    moon.position.set(
        Math.cos(moonAngle) * moonOrbitRad,
        0.21 * Math.sin(elapsed * 0.43),
        Math.sin(moonAngle) * moonOrbitRad
    );
    moon.rotation.y = elapsed * 0.009;
    moonLight.position.copy(moon.position);

    // Mondlicht
    const moonToSunDot = moon.position.clone().normalize().dot(sunLight.position.clone().normalize());
    moonLight.intensity = 0.10 + 0.10 * Math.max(0, -moonToSunDot);

    // Regen animieren
    rainDrops.forEach(drop => {
        drop.position.y -= 0.008;
        if (drop.position.y < 0.85) drop.position.y = 0.97 + Math.random() * 0.07;
    });

    // StÃ¤dte-Lichter nachts sichtbar
    cityLights.forEach((pl, idx) => {
        const cityPos = pl.position.clone().normalize();
        const nightDot = cityPos.dot(sunLight.position.clone().normalize());
        pl.intensity = nightDot < -0.18 ? 0.12 : 0.0;
    });

    controls.update();
    stats.update();
    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
}
</script>
</body>
</html>
