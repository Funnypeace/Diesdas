<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>🏃‍♂️ Endless Runner - Minispiel</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b1020; --panel:#121831; --accent:#4F46E5; --accent-2:#22C55E; --danger:#DC2626; --text:#E6F1FF; --muted:#A9BBDA;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;display:grid;place-items:center;background:radial-gradient(1200px 600px at 50% -10%,#1b2344 0%,#0b1020 45%,#05070f 100%);color:var(--text);font-family:Poppins,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}

    .game-container{width:min(100vw,980px);padding:18px}
    .game-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;gap:12px}
    .game-title{margin:0;font-size:clamp(18px,2.6vw,28px);letter-spacing:.3px}
    .score-container{display:flex;gap:10px;flex-wrap:wrap}
    .score-badge,.high-score-badge{background:#0e1430;border:1px solid #23306d;color:#cfe4ff;padding:6px 10px;border-radius:10px;font-weight:600;box-shadow:0 0 0 1px #1b2558 inset}

    .game-card{position:relative;background:linear-gradient(180deg,#0f1533 0%,#0b1124 100%);border:1px solid #223168;border-radius:18px;padding:14px;box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 0 40px #23306d20}
    .game-canvas{display:block;width:100%;height:auto;aspect-ratio: 2 / 1; background:#78b6ff; border-radius:12px; box-shadow:inset 0 0 32px #0003}

    .game-controls{position:absolute;inset:14px;display:grid;place-items:center;pointer-events:none}
    .game-instructions,.game-over,.game-playing{pointer-events:auto;text-align:center;background:#0c1333cc;border:1px solid #314096;backdrop-filter: blur(6px);padding:16px 18px;border-radius:14px;max-width: min(85%, 560px);box-shadow:0 12px 30px rgba(0,0,0,.35)}
    .hidden{display:none}

    .start-button,.restart-button{cursor:pointer;border:1px solid #4154f2;background:linear-gradient(180deg,#5c6bff,#3f4cf0);color:white;padding:10px 16px;border-radius:12px;font-weight:700;letter-spacing:.25px;margin-top:10px;box-shadow:0 6px 18px rgba(79,70,229,.45)}
    .start-button:hover,.restart-button:hover{filter:brightness(1.06)}

    .controls-hint{font-size:14px;color:#d9e7ff}
    kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.95em;border:1px solid #9fb7ff;background:#0d1d4a;border-radius:6px;padding:.15em .45em}

    .game-tips{margin-top:14px;background:linear-gradient(180deg,#0e1537 0%,#0b122b 100%);border:1px solid #1c2a63;padding:12px 14px;border-radius:14px}
    .game-tips h3{margin:4px 0 8px;font-size:18px}
    .game-tips li{color:#c6dcff}

    /* Touch helper zones (optional, invisible) */
    .touch-zones{position:absolute;inset:0;display:grid;grid-template-columns:1fr 1fr}
    .touch-zones > div{opacity:0}
  </style>
</head>
<body>
  <div class="game-container">
    <div class="game-header">
      <h1 class="game-title">🏃‍♂️ Endless Runner</h1>
      <div class="score-container">
        <div class="score-badge">Score: <span id="currentScore">0</span></div>
        <div class="high-score-badge">Best: <span id="highScore">0</span></div>
      </div>
    </div>

    <div class="game-card">
      <canvas id="gameCanvas" class="game-canvas" width="800" height="400"></canvas>

      <div class="game-controls">
        <div id="startScreen" class="game-instructions">
          <h2>🎮 Ready to Run?</h2>
          <p>Press <kbd>SPACE</kbd> or click to jump over obstacles!</p>
          <button id="startButton" class="start-button">Start Game</button>
        </div>

        <div id="playingScreen" class="game-playing hidden">
          <p class="controls-hint">Press <kbd>SPACE</kbd> or click to jump! (double‑jump möglich)</p>
        </div>

        <div id="gameOverScreen" class="game-over hidden">
          <h2>💥 Game Over!</h2>
          <p>Final Score: <strong id="finalScore">0</strong></p>
          <p id="newRecordMessage" class="new-record hidden">🏆 New High Score!</p>
          <button id="restartButton" class="restart-button">Play Again</button>
        </div>
      </div>

      <!-- Optional: Touch zones for mobile (left = jump, right = jump) -->
      <div class="touch-zones" id="touchZones">
        <div data-act="jump"></div>
        <div data-act="jump"></div>
      </div>
    </div>

    <div class="game-tips">
      <h3>💡 Tips:</h3>
      <ul>
        <li>Time your jumps carefully to avoid the red obstacles</li>
        <li>The game gets faster as your score increases</li>
        <li>Try to beat your high score!</li>
      </ul>
    </div>
  </div>

  <script>
  class EndlessRunnerGame {
    constructor(){
      this.canvas = document.getElementById('gameCanvas');
      this.ctx = this.canvas.getContext('2d');
      this.state = 'start';
      this.score = 0;
      this.highScore = +(localStorage.getItem('runner-high')||0);
      this.last = performance.now();
      this.anim = null;

      // Audio (tiny bleep SFX)
      this.ac = null;

      this.cfg = {
        w: 800, h: 400,
        groundH: 86,
        gravity: 2000, // px/s^2 (delta-time based)
        jumpV: -650,
        jumpBuffer: 120, // ms after press buffered
        coyoteTime: 120, // ms after leaving ground
        doubleJump: true,
        bgSpeed: 100 // px/s for parallax base
      };

      this.resetRunVars();
      this.bind();
      this.updateUI();
      this.drawStaticScene();
    }

    resetRunVars(){
      this.player = { x: 110, y: 0, w: 44, h: 44, vy: 0, onGround:false, canDouble:true, lastGroundT:0, lastJumpPressT:-9999 };
      this.player.y = this.cfg.h - this.cfg.groundH - this.player.h;
      this.obstacles = [];
      this.spawnCooldown = 0;
      this.gameSpeed = 280; // px/s object speed
      this.score = 0;
      this.scoreTimer = 0;
      this.bg = { x:0 };
      this.particles = [];
    }

    bind(){
      const jumpPress = ()=>this.handleJumpInput();
      document.addEventListener('keydown', e=>{ if(e.code==='Space'){ e.preventDefault(); jumpPress(); }});
      this.canvas.addEventListener('pointerdown', jumpPress);
      document.getElementById('startButton').addEventListener('click', ()=>this.start());
      document.getElementById('restartButton').addEventListener('click', ()=>this.restart());
      // Resize for crisp rendering
      addEventListener('resize', ()=>this.drawStaticScene());
    }

    start(){
      if(this.state==='playing') return;
      this.state='playing';
      this.resetRunVars();
      this.updateUI();
      this.last = performance.now();
      this.loop(this.last);
    }
    restart(){ this.state='start'; cancelAnimationFrame(this.anim); this.updateUI(); this.drawStaticScene(); }

    handleJumpInput(){
      if(this.state==='start'){ this.start(); return; }
      if(this.state==='gameOver'){ this.restart(); return; }
      const t = performance.now();
      this.player.lastJumpPressT = t;
      // If jump is immediately allowed, apply now (so clicks feel instant)
      if(this.canJump(t)) this.doJump(false);
    }

    canJump(t){
      const groundY = this.cfg.h - this.cfg.groundH - this.player.h;
      const onGround = Math.abs(this.player.y - groundY) < 0.5;
      if(onGround) return true;
      if(this.cfg.doubleJump && this.player.canDouble) return true;
      // coyote
      if(t - this.player.lastGroundT <= this.cfg.coyoteTime) return true;
      return false;
    }

    doJump(isBuffered){
      // sound
      this.bleep(880, 0.05);
      // logic
      const groundY = this.cfg.h - this.cfg.groundH - this.player.h;
      const onGround = Math.abs(this.player.y - groundY) < 0.5;
      this.player.vy = this.cfg.jumpV;
      if(!onGround){ this.player.canDouble = false; }
    }

    loop(now){
      const dt = Math.min(0.033, (now - this.last)/1000);
      this.last = now;
      this.update(dt, now);
      this.render();
      if(this.state==='playing') this.anim = requestAnimationFrame(t=>this.loop(t));
    }

    update(dt, now){
      // Gravity
      this.player.vy += this.cfg.gravity*dt;
      this.player.y += this.player.vy*dt;
      const groundY = this.cfg.h - this.cfg.groundH - this.player.h;
      if(this.player.y >= groundY){
        if(!this.player.onGround){
          this.landFX();
        }
        this.player.y = groundY; this.player.vy = 0; this.player.onGround = true; this.player.canDouble = true; this.player.lastGroundT = now;
      } else {
        this.player.onGround = false;
      }

      // Jump buffering
      if(now - this.player.lastJumpPressT <= this.cfg.jumpBuffer){
        if(this.canJump(now)){
          this.player.lastJumpPressT = -9999; // consume
          this.doJump(true);
        }
      }

      // Background parallax
      this.bg.x -= this.cfg.bgSpeed*dt;
      if(this.bg.x < -this.cfg.w) this.bg.x += this.cfg.w;

      // Spawn obstacles
      this.spawnCooldown -= dt;
      if(this.spawnCooldown <= 0){
        const gapMin = 0.9; // seconds at current speed
        const width = 28 + (Math.random()*18|0);
        const height = 40 + (Math.random()*35|0);
        this.obstacles.push({ x:this.cfg.w+20, y:this.cfg.h - this.cfg.groundH - height, w:width, h:height, c:'#DC2626' });
        // next in [0.7..1.3] scaled by speed (keeps playable)
        this.spawnCooldown = (gapMin + Math.random()*0.6);
      }

      // Move obstacles & collisions
      for(let i=this.obstacles.length-1;i>=0;i--){
        const o = this.obstacles[i];
        o.x -= this.gameSpeed*dt;
        if(this.intersects(this.player,o)){
          this.gameOver();
          return;
        }
        if(o.x + o.w < -10) this.obstacles.splice(i,1);
      }

      // Score
      this.score += this.gameSpeed*dt*0.05; // tuned
      // Difficulty ramp
      this.gameSpeed = Math.min(520, 280 + this.score*1.2);

      this.updateUIRuntime();
    }

    gameOver(){
      this.state='gameOver';
      cancelAnimationFrame(this.anim);
      this.bleep(180, 0.2);
      const s = Math.floor(this.score);
      if(s > this.highScore){ this.highScore = s; localStorage.setItem('runner-high', this.highScore); document.getElementById('newRecordMessage').classList.remove('hidden'); }
      else { document.getElementById('newRecordMessage').classList.add('hidden'); }
      this.updateUI();
    }

    updateUI(){
      document.getElementById('currentScore').textContent = Math.floor(this.score);
      document.getElementById('highScore').textContent = this.highScore;
      document.getElementById('finalScore').textContent = Math.floor(this.score);
      document.getElementById('startScreen').classList.toggle('hidden', this.state!=='start');
      document.getElementById('playingScreen').classList.toggle('hidden', this.state!=='playing');
      document.getElementById('gameOverScreen').classList.toggle('hidden', this.state!=='gameOver');
    }

    updateUIRuntime(){
      document.getElementById('currentScore').textContent = Math.floor(this.score);
      document.getElementById('highScore').textContent = this.highScore;
      document.getElementById('finalScore').textContent = Math.floor(this.score);
    }

    drawStaticScene(){
      // draw a pretty idle scene when not playing
      this.ctx.clearRect(0,0,this.cfg.w,this.cfg.h);
      this.drawBackground(0);
      this.drawGround();
      this.drawPlayer(this.player.x, this.player.y);
    }

    render(){
      const ctx = this.ctx; const W=this.cfg.w, H=this.cfg.h;
      ctx.clearRect(0,0,W,H);
      this.drawBackground(this.bg.x);
      this.drawGround();

      // obstacles
      for(const o of this.obstacles){
        ctx.fillStyle = o.c; ctx.fillRect(o.x,o.y,o.w,o.h);
        ctx.fillStyle = '#991B1B'; ctx.fillRect(o.x+4,o.y+4,Math.max(0,o.w-8),Math.max(0,o.h-8));
      }

      // player
      this.drawPlayer(this.player.x, this.player.y);

      // particles
      for(let i=this.particles.length-1;i>=0;i--){
        const p=this.particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.4; p.life-=1; if(p.life<=0) this.particles.splice(i,1);
        ctx.globalAlpha = Math.max(0,p.life/20); ctx.fillStyle=p.c; ctx.fillRect(p.x,p.y,2,2); ctx.globalAlpha=1;
      }
    }

    drawBackground(offset){
      const ctx=this.ctx, W=this.cfg.w, H=this.cfg.h, G=this.cfg.groundH;
      // sky gradient
      const g=ctx.createLinearGradient(0,0,0,H-G);
      g.addColorStop(0,'#8fd5ff'); g.addColorStop(1,'#7bbcff');
      ctx.fillStyle=g; ctx.fillRect(0,0,W,H-G);

      // distant mountains (parallax)
      ctx.fillStyle='#5ea0d6';
      this.drawHills(offset*0.3, H-G-90, 80, 140, 120);
      ctx.fillStyle='#4a8bc5';
      this.drawHills(offset*0.6, H-G-60, 60, 120, 100);

      // clouds
      ctx.fillStyle='rgba(255,255,255,0.8)';
      for(let i=0;i<5;i++) this.cloud((offset+i*180)% (W+200), 60+i*18);
    }

    drawGround(){
      const ctx=this.ctx, W=this.cfg.w, H=this.cfg.h, G=this.cfg.groundH;
      ctx.fillStyle = '#22C55E'; ctx.fillRect(0,H-G,W,G);
      ctx.fillStyle = '#16A34A'; for(let i=0;i<W;i+=22) ctx.fillRect(i,H-G,W>10?12:10,10);
    }

    drawHills(offset, baseY, amp, wave, step){
      const ctx=this.ctx, W=this.cfg.w;
      ctx.beginPath(); ctx.moveTo(0, baseY);
      for(let x=-200;x<=W+200;x+=step){
        const y = baseY + Math.sin((x+offset)/wave)*amp*0.2;
        ctx.lineTo(x,y);
      }
      ctx.lineTo(W, 600); ctx.lineTo(0,600); ctx.closePath(); ctx.fill();
    }

    cloud(x,y){
      const ctx=this.ctx; x = (x+this.cfg.w+200)%(this.cfg.w+200)-100; // wrap
      ctx.beginPath(); ctx.arc(x, y, 20, 0, Math.PI*2);
      ctx.arc(x+20, y, 30, 0, Math.PI*2);
      ctx.arc(x+45, y+5, 22, 0, Math.PI*2); ctx.fill();
    }

    drawPlayer(x,y){
      const ctx=this.ctx; ctx.fillStyle = '#4F46E5'; ctx.fillRect(x,y,44,44);
      ctx.fillStyle = 'white'; ctx.fillRect(x+9,y+10,9,9); ctx.fillRect(x+26,y+10,9,9);
      // tiny shadow
      ctx.globalAlpha=.15; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(x+22,y+46,18,6,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    }

    landFX(){
      // landing particles
      for(let i=0;i<10;i++) this.particles.push({x:this.player.x+22,y:this.player.y+44,vx:(Math.random()-0.5)*2,vy: -Math.random()*2,life: 18+Math.random()*10,c:'#b3ffb3'});
    }

    intersects(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

    bleep(freq, dur){
      try{
        this.ac = this.ac || new (window.AudioContext||window.webkitAudioContext)();
        const o=this.ac.createOscillator(); const g=this.ac.createGain();
        o.frequency.value=freq; o.type='sine'; g.gain.value=0.04; o.connect(g); g.connect(this.ac.destination);
        o.start(); g.gain.exponentialRampToValueAtTime(0.0001, this.ac.currentTime+dur); o.stop(this.ac.currentTime+dur);
      }catch(e){}
    }
  }

  document.addEventListener('DOMContentLoaded', ()=>{ new EndlessRunnerGame(); });
  </script>
</body>
</html>
