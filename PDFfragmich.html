<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frag das PDF - Lokale PDF Suche</title>
    <meta name="description" content="Lokale, client-seitige PDF-Suche ohne Server. Perfekt f√ºr GitHub Pages und Vercel.">
    
    <!-- PDF.js von CDN laden -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.min.js"></script>
    
    <style>
        :root {
            --primary: #3498db;
            --primary-dark: #2980b9;
            --success: #27ae60;
            --warning: #f39c12;
            --danger: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --gray: #7f8c8d;
            --white: #ffffff;
            --shadow: 0 4px 12px rgba(0,0,0,0.1);
            --border-radius: 8px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--dark);
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: var(--white);
            border-radius: 15px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: var(--white);
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .main-content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid var(--light);
            border-radius: var(--border-radius);
            background: #fafafa;
        }

        .upload-area {
            border: 3px dashed var(--light);
            border-radius: var(--border-radius);
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--white);
        }

        .upload-area:hover,
        .upload-area.dragover {
            border-color: var(--primary);
            background: #f8f9ff;
            transform: translateY(-2px);
        }

        .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: var(--white);
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        .btn:disabled {
            background: var(--gray);
            cursor: not-allowed;
            transform: none;
        }

        .search-container {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-input {
            flex: 1;
            min-width: 300px;
            padding: 15px 20px;
            border: 2px solid var(--light);
            border-radius: 25px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .search-input:focus {
            border-color: var(--primary);
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-input {
            width: 80px;
            padding: 8px;
            border: 1px solid var(--light);
            border-radius: 4px;
            text-align: center;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--light);
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--success) 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .status {
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 15px 0;
            font-weight: 500;
        }

        .status.info {
            background: #e8f4fd;
            border: 1px solid var(--primary);
            color: var(--primary-dark);
        }

        .status.success {
            background: #e8f6f0;
            border: 1px solid var(--success);
            color: #1e8449;
        }

        .status.warning {
            background: #fef5e7;
            border: 1px solid var(--warning);
            color: #b7950b;
        }

        .pdf-info {
            display: none;
            background: var(--white);
            border: 1px solid var(--success);
            border-radius: var(--border-radius);
            padding: 15px;
            margin: 15px 0;
        }

        .results-container {
            margin-top: 20px;
        }

        .result-item {
            background: var(--white);
            border: 1px solid var(--light);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            border-left: 4px solid var(--primary);
        }

        .result-item:hover {
            box-shadow: var(--shadow);
            transform: translateX(5px);
        }

        .result-meta {
            color: var(--gray);
            font-size: 0.9rem;
            margin-bottom: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .result-text {
            line-height: 1.6;
            color: var(--dark);
        }

        .highlight {
            background: linear-gradient(120deg, #fff3cd 0%, #ffeaa7 100%);
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }

        .badge {
            background: var(--primary);
            color: var(--white);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .search-container {
                flex-direction: column;
            }
            
            .search-input {
                min-width: auto;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Frag das PDF</h1>
            <p>Lokale, client-seitige PDF-Analyse ohne Server</p>
        </div>

        <div class="main-content">
            <!-- Upload Bereich -->
            <div class="section">
                <h3>üìÑ PDF-Datei laden</h3>
                <div class="upload-area" id="uploadArea">
                    <div>
                        <p><strong>PDF-Datei hier ablegen oder klicken zum Ausw√§hlen</strong></p>
                        <p>Alle Daten bleiben lokal in Ihrem Browser</p>
                        <button class="btn" onclick="document.getElementById('fileInput').click()">
                            Datei ausw√§hlen
                        </button>
                        <input type="file" id="fileInput" class="file-input" accept=".pdf">
                    </div>
                </div>
                
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                
                <div id="status" class="status info" style="display: none;"></div>
                <div id="pdfInfo" class="pdf-info"></div>
            </div>

            <!-- Suchbereich -->
            <div class="section">
                <h3>üîé Suche</h3>
                <div class="search-container">
                    <input type="text" id="searchInput" class="search-input" 
                           placeholder="Frage stellen oder Begriffe suchen..." disabled>
                    <button id="searchBtn" class="btn" disabled>Suchen</button>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label for="chunkSize">Chunk-Gr√∂√üe:</label>
                        <input type="number" id="chunkSize" class="control-input" 
                               value="300" min="100" max="1000" step="50">
                    </div>
                    <div class="control-group">
                        <label for="maxResults">Max. Ergebnisse:</label>
                        <input type="number" id="maxResults" class="control-input" 
                               value="10" min="1" max="50" step="1">
                    </div>
                </div>
            </div>

            <!-- Ergebnisse -->
            <div class="section">
                <h3>üìã Suchergebnisse</h3>
                <div id="resultsContainer" class="results-container">
                    <p class="status info">Laden Sie eine PDF-Datei und starten Sie eine Suche.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // PDF.js Worker konfigurieren
        pdfjsLib.GlobalWorkerOptions.workerSrc = 
            'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.worker.min.js';

        class PDFSearchEngine {
            constructor() {
                this.pdfText = '';
                this.chunks = [];
                this.pdfDoc = null;
                this.stopWords = new Set([
                    // Deutsche Stopw√∂rter
                    'der', 'die', 'das', 'den', 'dem', 'des', 'ein', 'eine', 'einer', 'eines', 'einem', 'einen',
                    'und', 'oder', 'aber', 'doch', 'sondern', 'jedoch', 'dennoch', 'trotzdem',
                    'ist', 'sind', 'war', 'waren', 'hat', 'haben', 'hatte', 'hatten', 'wird', 'werden',
                    'ich', 'du', 'er', 'sie', 'es', 'wir', 'ihr', 'sie', 'mich', 'dich', 'sich',
                    'in', 'an', 'auf', 'bei', 'mit', 'nach', 'vor', '√ºber', 'unter', 'zwischen',
                    'f√ºr', 'gegen', 'ohne', 'durch', 'um', 'von', 'zu', 'aus', 'bei', 'seit',
                    // Englische Stopw√∂rter
                    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
                    'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did',
                    'i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them',
                    'this', 'that', 'these', 'those', 'there', 'here', 'where', 'when', 'what', 'how', 'why'
                ]);
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                const fileInput = document.getElementById('fileInput');
                const uploadArea = document.getElementById('uploadArea');
                const searchBtn = document.getElementById('searchBtn');
                const searchInput = document.getElementById('searchInput');

                // Datei-Events
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                
                // Drag & Drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0 && files[0].type === 'application/pdf') {
                        this.processPDF(files[0]);
                    }
                });

                // Suche
                searchBtn.addEventListener('click', () => this.performSearch());
                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.performSearch();
                });

                // Chunk-Gr√∂√üe √Ñnderung
                document.getElementById('chunkSize').addEventListener('change', () => {
                    if (this.pdfText) {
                        this.createChunks();
                        this.showStatus('Chunks wurden aktualisiert.', 'success');
                    }
                });
            }

            async handleFileSelect(event) {
                const file = event.target.files[0];
                if (file && file.type === 'application/pdf') {
                    await this.processPDF(file);
                }
            }

            async processPDF(file) {
                try {
                    this.showProgress(0);
                    this.showStatus('PDF wird geladen...', 'info');

                    const arrayBuffer = await file.arrayBuffer();
                    this.pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                    
                    this.showProgress(20);
                    this.showStatus('Text wird extrahiert...', 'info');

                    let fullText = '';
                    const numPages = this.pdfDoc.numPages;

                    for (let i = 1; i <= numPages; i++) {
                        const page = await this.pdfDoc.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items
                            .map(item => item.str)
                            .join(' ')
                            .replace(/\s+/g, ' ')
                            .trim();
                        
                        if (pageText) {
                            fullText += `[Seite ${i}] ${pageText}\n\n`;
                        }
                        
                        this.showProgress(20 + (i / numPages) * 60);
                    }

                    this.pdfText = fullText;
                    this.showProgress(80);
                    this.showStatus('Chunks werden erstellt...', 'info');

                    this.createChunks();
                    this.showProgress(100);

                    // UI Updates
                    this.showPDFInfo(file.name, numPages);
                    this.enableSearch();
                    this.hideProgress();
                    this.showStatus('PDF erfolgreich verarbeitet!', 'success');

                } catch (error) {
                    console.error('PDF-Verarbeitungsfehler:', error);
                    this.showStatus('Fehler beim Verarbeiten der PDF-Datei.', 'warning');
                    this.hideProgress();
                }
            }

            createChunks() {
                const chunkSize = parseInt(document.getElementById('chunkSize').value) || 300;
                const overlap = Math.floor(chunkSize * 0.2); // 20% √úberlappung
                
                this.chunks = [];
                
                // Erst in Abs√§tze aufteilen
                const paragraphs = this.pdfText.split(/\n\n+/).filter(p => p.trim().length > 0);
                
                paragraphs.forEach(paragraph => {
                    const words = paragraph.split(/\s+/);
                    
                    if (words.length <= chunkSize) {
                        // Kurzer Absatz - als ganzes Chunk
                        this.chunks.push({
                            text: paragraph.trim(),
                            words: words,
                            pageInfo: this.extractPageInfo(paragraph)
                        });
                    } else {
                        // Langer Absatz - in √ºberlappende Chunks aufteilen
                        for (let i = 0; i < words.length; i += chunkSize - overlap) {
                            const chunkWords = words.slice(i, i + chunkSize);
                            const chunkText = chunkWords.join(' ');
                            
                            this.chunks.push({
                                text: chunkText,
                                words: chunkWords,
                                pageInfo: this.extractPageInfo(chunkText)
                            });
                        }
                    }
                });
            }

            extractPageInfo(text) {
                const match = text.match(/\[Seite (\d+)\]/);
                return match ? parseInt(match[1]) : null;
            }

            tokenize(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s√§√∂√º√ü]/g, ' ')
                    .split(/\s+/)
                    .filter(word => word.length > 2 && !this.stopWords.has(word));
            }

            calculateRelevanceScore(chunk, queryTerms) {
                const chunkTokens = this.tokenize(chunk.text);
                const chunkText = chunk.text.toLowerCase();
                
                let score = 0;
                
                queryTerms.forEach(term => {
                    const termLower = term.toLowerCase();
                    
                    // Exakte Phrasen-Treffer (h√∂chste Gewichtung)
                    const phraseMatches = (chunkText.match(new RegExp(termLower, 'g')) || []).length;
                    score += phraseMatches * 10;
                    
                    // Wort-Treffer
                    const wordMatches = chunkTokens.filter(token => 
                        token.includes(termLower) || termLower.includes(token)
                    ).length;
                    score += wordMatches * 3;
                    
                    // √Ñhnlichkeits-Bonus f√ºr verwandte Begriffe
                    chunkTokens.forEach(token => {
                        if (this.calculateSimilarity(token, termLower) > 0.7) {
                            score += 1;
                        }
                    });
                });
                
                // L√§ngen-Normalisierung
                return score / Math.sqrt(chunkTokens.length);
            }

            calculateSimilarity(str1, str2) {
                const longer = str1.length > str2.length ? str1 : str2;
                const shorter = str1.length > str2.length ? str2 : str1;
                
                if (longer.length === 0) return 1.0;
                
                const distance = this.levenshteinDistance(longer, shorter);
                return (longer.length - distance) / longer.length;
            }

            levenshteinDistance(str1, str2) {
                const matrix = [];
                
                for (let i = 0; i <= str2.length; i++) {
                    matrix[i] = [i];
                }
                
                for (let j = 0; j <= str1.length; j++) {
                    matrix[0][j] = j;
                }
                
                for (let i = 1; i <= str2.length; i++) {
                    for (let j = 1; j <= str1.length; j++) {
                        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }
                
                return matrix[str2.length][str1.length];
            }

            performSearch() {
                const query = document.getElementById('searchInput').value.trim();
                const maxResults = parseInt(document.getElementById('maxResults').value) || 10;
                
                if (!query) {
                    this.showResults([], query);
                    return;
                }

                if (this.chunks.length === 0) {
                    this.showStatus('Bitte laden Sie zuerst eine PDF-Datei.', 'warning');
                    return;
                }

                const startTime = performance.now();
                const queryTerms = query.split(/\s+/).filter(term => term.length > 1);
                
                const results = this.chunks
                    .map(chunk => ({
                        chunk,
                        score: this.calculateRelevanceScore(chunk, queryTerms)
                    }))
                    .filter(result => result.score > 0)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, maxResults);

                const endTime = performance.now();
                this.showResults(results, query, endTime - startTime);
            }

            showResults(results, query, searchTime = 0) {
                const container = document.getElementById('resultsContainer');
                
                if (results.length === 0) {
                    container.innerHTML = `
                        <p class="status warning">
                            Keine Ergebnisse f√ºr "${query}" gefunden.
                        </p>
                    `;
                    return;
                }

                let html = `
                    <div class="status success">
                        ${results.length} Ergebnisse f√ºr "${query}" 
                        (${searchTime.toFixed(1)}ms)
                    </div>
                `;

                results.forEach((result, index) => {
                    const highlightedText = this.highlightMatches(result.chunk.text, query);
                    const pageInfo = result.chunk.pageInfo;
                    
                    html += `
                        <div class="result-item">
                            <div class="result-meta">
                                <span class="badge">Treffer ${index + 1}</span>
                                ${pageInfo ? `<span class="badge">Seite ${pageInfo}</span>` : ''}
                                <span class="badge">Score: ${result.score.toFixed(2)}</span>
                            </div>
                            <div class="result-text">${highlightedText}</div>
                        </div>
                    `;
                });

                container.innerHTML = html;
            }

            highlightMatches(text, query) {
                const queryTerms = query.split(/\s+/).filter(term => term.length > 1);
                let highlightedText = text;

                queryTerms.forEach(term => {
                    const regex = new RegExp(`(${this.escapeRegex(term)})`, 'gi');
                    highlightedText = highlightedText.replace(regex, '<span class="highlight">$1</span>');
                });

                return highlightedText;
            }

            escapeRegex(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            showProgress(percentage) {
                const progressBar = document.getElementById('progressBar');
                const progressFill = document.getElementById('progressFill');
                
                progressBar.style.display = 'block';
                progressFill.style.width = percentage + '%';
            }

            hideProgress() {
                setTimeout(() => {
                    document.getElementById('progressBar').style.display = 'none';
                }, 1000);
            }

            showStatus(message, type = 'info') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
                status.style.display = 'block';
            }

            showPDFInfo(filename, pageCount) {
                const info = document.getElementById('pdfInfo');
                info.innerHTML = `
                    <strong>üìÑ ${filename}</strong><br>
                    Seiten: ${pageCount} | Chunks: ${this.chunks.length} | 
                    Zeichen: ${this.pdfText.length.toLocaleString()}
                `;
                info.style.display = 'block';
            }

            enableSearch() {
                document.getElementById('searchInput').disabled = false;
                document.getElementById('searchBtn').disabled = false;
                document.getElementById('searchInput').focus();
            }
        }

        // Initialisierung
        document.addEventListener('DOMContentLoaded', () => {
            window.pdfSearchEngine = new PDFSearchEngine();
        });
    </script>
</body>
</html>
