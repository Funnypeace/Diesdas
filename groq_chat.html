<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Groq Chat – HTML + JS Starter</title>
  <!--
    ⚠️ WICHTIG (Sicherheit & API-Key)
    Browser-Apps sollten KEINE geheimen API-Keys enthalten. Richte dir einen kleinen Proxy ein (z. B. /api/groq),
    der den Request serverseitig an https://api.groq.com/openai/v1/chat/completions weiterleitet und den Key dort setzt.

    Minimaler Cloudflare-Worker (TypeScript) als Proxy (nur als Referenz, NICHT in diesem HTML ausführen):

    export default {
      async fetch(req, env) {
        const url = "https://api.groq.com/openai/v1/chat/completions";
        const body = await req.text();
        const resp = await fetch(url, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${env.GROQ_API_KEY}`,
            "Content-Type": "application/json",
          },
          body,
        });
        // CORS für dein Frontend erlauben
        const headers = new Headers(resp.headers);
        headers.set("Access-Control-Allow-Origin", "*");
        headers.set("Access-Control-Expose-Headers", "*\");
        return new Response(resp.body, { status: resp.status, statusText: resp.statusText, headers });
      }
    }

    In diesem Frontend wird davon ausgegangen, dass ein Proxy unter /api/groq erreichbar ist.
  -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; }
    ::selection { background: #e5e7eb; }
    .bubble { border-radius: 1.25rem; }
    .prose pre { white-space: pre-wrap; word-wrap: break-word; }
    .spinner { width: 16px; height: 16px; border: 2px solid #e5e7eb; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body class="min-h-full bg-gradient-to-b from-white to-slate-50 text-slate-800">
  <div class="max-w-4xl mx-auto p-4 md:p-6 lg:p-8">
    <header class="mb-4 md:mb-6 flex items-center justify-between">
      <h1 class="text-2xl md:text-3xl font-semibold tracking-tight">Groq Chat <span class="text-slate-400 text-base">(HTML + JS Starter)</span></h1>
      <div class="flex items-center gap-3 text-sm">
        <a href="#" class="opacity-70 hover:opacity-100">Docs</a>
        <a href="#" class="opacity-70 hover:opacity-100">GitHub</a>
      </div>
    </header>

    <!-- Controls -->
    <section class="mb-4 grid grid-cols-1 md:grid-cols-4 gap-3">
      <label class="flex flex-col gap-1 md:col-span-2">
        <span class="text-sm text-slate-500">Modell</span>
        <select id="model" class="px-3 py-2 rounded-2xl bg-white shadow-sm ring-1 ring-slate-200 focus:outline-none focus:ring-2 focus:ring-slate-400">
          <option value="llama-3.1-70b-versatile">Llama 3.1 70B (versatile)</option>
          <option value="llama-3.1-8b-instant">Llama 3.1 8B (instant)</option>
        </select>
      </label>
      <label class="flex flex-col gap-1">
        <span class="text-sm text-slate-500">Temperatur <span id="tempVal" class="font-mono">0.2</span></span>
        <input id="temperature" type="range" min="0" max="1" step="0.1" value="0.2" class="w-full" />
      </label>
      <label class="flex flex-col gap-1">
        <span class="text-sm text-slate-500">Max Tokens</span>
        <input id="maxTokens" type="number" min="1" max="4096" value="1024" class="px-3 py-2 rounded-2xl bg-white shadow-sm ring-1 ring-slate-200 focus:outline-none focus:ring-2 focus:ring-slate-400" />
      </label>
    </section>

    <!-- Chat area -->
    <main id="chat" class="h-[60vh] md:h-[65vh] overflow-y-auto rounded-2xl bg-white ring-1 ring-slate-200 shadow-sm p-4 flex flex-col gap-3">
      <div class="self-start bubble bg-slate-100 px-4 py-3">
        <div class="text-xs text-slate-500 mb-1">Assistant</div>
        <div>Hi! Stell mir eine Frage – ich antworte mit dem ausgewählten Groq‑Modell.</div>
      </div>
    </main>

    <!-- Composer -->
    <form id="composer" class="mt-3 flex items-end gap-2">
      <textarea id="input" rows="1" placeholder="Schreibe deine Nachricht… (Shift+Enter = Zeilenumbruch)" class="flex-1 px-4 py-3 rounded-2xl bg-white ring-1 ring-slate-200 shadow-sm focus:outline-none focus:ring-2 focus:ring-slate-400 resize-none"></textarea>
      <button id="send" type="submit" class="px-4 py-3 rounded-2xl bg-slate-900 text-white shadow-sm hover:bg-slate-800 active:bg-slate-900 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2">
        <span>Senden</span>
        <div id="loading" class="spinner hidden"></div>
      </button>
    </form>

    <p class="mt-2 text-xs text-slate-500">
      Hinweis: Dieses Frontend erwartet einen Proxy unter <code>/api/groq</code>. Er sollte Requests an <code>https://api.groq.com/openai/v1/chat/completions</code> weiterleiten und den API‑Key serverseitig setzen.
    </p>
  </div>

  <script>
    "use strict";

    const chat = document.getElementById("chat");
    const form = document.getElementById("composer");
    const input = document.getElementById("input");
    const sendBtn = document.getElementById("send");
    const loading = document.getElementById("loading");
    const modelEl = document.getElementById("model");
    const tempEl = document.getElementById("temperature");
    const tempVal = document.getElementById("tempVal");
    const maxTokensEl = document.getElementById("maxTokens");

    let abortCtrl = null;

    tempEl.addEventListener("input", () => (tempVal.textContent = (+tempEl.value).toFixed(1)));

    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        form.requestSubmit();
      }
    });

    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const content = input.value.trim();
      if (!content) return;
      input.value = "";

      const userBubble = renderBubble("user", content);
      chat.appendChild(userBubble);
      chat.scrollTop = chat.scrollHeight;

      const assistantBubble = renderBubble("assistant", "");
      const streamEl = assistantBubble.querySelector(".stream");
      chat.appendChild(assistantBubble);
      chat.scrollTop = chat.scrollHeight;

      setLoading(true);

      abortCtrl = new AbortController();

      try {
        // OpenAI-kompatibles Streaming via SSE (data: {json})
        const resp = await fetch("/api/groq", {
          method: "POST",
          signal: abortCtrl.signal,
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            model: modelEl.value,
            messages: [
              { role: "system", content: "Du bist ein hilfreicher, präziser KI-Assistent." },
              { role: "user", content }
            ],
            temperature: Number(tempEl.value),
            max_tokens: Number(maxTokensEl.value),
            stream: true,
          }),
        });

        if (!resp.ok) {
          const text = await resp.text();
          throw new Error(`HTTP ${resp.status} – ${text}`);
        }

        const reader = resp.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });

          // SSE-Events sind durch doppelten Zeilenumbruch getrennt
          const parts = buffer.split(/\n\n/);
          buffer = parts.pop() ?? "";

          for (const part of parts) {
            const line = part.trim();
            if (!line.startsWith("data:")) continue;
            const payload = line.slice(5).trim();
            if (payload === "[DONE]") { buffer = ""; break; }
            try {
              const json = JSON.parse(payload);
              const delta = json.choices?.[0]?.delta?.content ?? "";
              if (delta) {
                streamEl.textContent += delta;
                chat.scrollTop = chat.scrollHeight;
              }
            } catch (err) {
              // Ignoriere Keep-Alives / unvollständige Chunks
            }
          }
        }
      } catch (err) {
        console.error(err);
        streamEl.innerHTML = `<span class="text-red-600">Fehler: ${escapeHtml(String(err.message || err))}</span>`;
      } finally {
        setLoading(false);
        abortCtrl = null;
      }
    });

    function setLoading(is) {
      sendBtn.disabled = is;
      loading.classList.toggle("hidden", !is);
    }

    function renderBubble(role, text) {
      const isUser = role === "user";
      const wrap = document.createElement("div");
      wrap.className = `${isUser ? "self-end bg-slate-900 text-white" : "self-start bg-slate-100"} bubble px-4 py-3 max-w-[85%] shadow`;
      wrap.innerHTML = `
        <div class="text-xs ${isUser ? "text-slate-300" : "text-slate-500"} mb-1">${isUser ? "Du" : "Assistant"}</div>
        <div class="prose prose-sm whitespace-pre-wrap break-words"><span class="stream"></span></div>
      `;
      wrap.querySelector(".stream").textContent = text;
      return wrap;
    }

    function escapeHtml(s) {
      return s.replace(/[&<>"']/g, (c) => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
      })[c]);
    }

    // Optional: Abbrechen mit ESC
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && abortCtrl) {
        abortCtrl.abort();
      }
    });
  </script>
</body>
</html>
